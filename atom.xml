<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zoro</title>
  
  <subtitle>When u want to fly, I guess the wind will do a favor.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-16T00:41:53.414Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zoilo Xi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript事件</title>
    <link href="http://yoursite.com/2018/06/16/javascript%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/06/16/javascript事件/</id>
    <published>2018-06-16T00:37:21.000Z</published>
    <updated>2018-06-16T00:41:53.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript事件-发生什么事了？"><a href="#JavaScript事件-发生什么事了？" class="headerlink" title="JavaScript事件:发生什么事了？"></a>JavaScript事件:发生什么事了？</h1><p>在最近的代码中,我同时给document元素和其内部元素添加click事件监听,根据事件监听的结果来显示隐藏某个提示框.但在实现过程中,我发现,当内部元素点击显示提示框后,又会立马隐藏.看别人实现的方法,才发觉我使用的事件监听有问题,由此致使我再次读一读JavaScript中事件模型及相关知识.基于此,便有写下自己的理解。</p><a id="more"></a><h2 id="一-what-happened-事件模型"><a href="#一-what-happened-事件模型" class="headerlink" title="一. what happened: 事件模型"></a>一. what happened: 事件模型</h2><p>当用户对页面进行键盘/鼠标操作时,页面本质上发生了什么事？如何来响应用户的操作？</p><p>要了解这个问题,就要知道浏览器处理用户的操作是一个怎么样的流程.在JavaScript中,我们把用户对页面的操作当作一次事件,event. 这个事件的对象就是用户操作的对象,例如用户点击链接\按钮,那么链接\按钮就是事件的对象,注意,我们这里的链接按钮都是指页面中的dom元素来说的.但是,我们都知道,页面中的各个元素是通过一个dom树的结构形式来渲染显示.也就是说,你点击dom树上的一片叶子,比如按钮,那么在树(dom树)看来,你点了树(叶子是树上的),你也点了树枝(叶子也是某个树枝上的),你还点了枝丫(叶子长在枝丫末端),最后才是点击了叶子本身.那么问题来了,dom树的这些结构都认为你点击了它们,怎么给它们认为的点击自己排一个先后顺序呢？</p><p>讲到这里,为了理清这个所谓的先后顺序,历史上,Microsoft将这个顺序指定为从具体到笼统,也就是说,点击的先后顺序是从“叶子-&gt;枝丫-&gt;树枝-&gt;树”这样的一个顺序,又由于在这个过程中,点击的对象大小是逐渐变大的,就像泡泡慢慢变大一样,所以把它叫做“冒泡”.但是Netscape却不是这样认为,应该是先有树,才能有树枝,才能有枝丫,才能有叶子让你点击.所以顺序应该要反过来,是“树-&gt;树枝-&gt;枝丫-&gt;叶子”的这个顺序,可以看出,这个过程就像在树上抓捕到那个被具体点击的叶子,因此这个过程被称为“捕获”.后来,为了避免争端,W3C将二者结合起来,建立了一个事件模型.总结一下,就是,现阶段的W3C事件模型的四要素:</p><ul><li>前提: DOM树</li><li>第一阶段: 捕获阶段</li><li>第二阶段: 得到目标</li><li>第三阶段: 冒泡阶段</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1225373-21d8b29bb5a5934c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/394" alt="事件模型"></p><h2 id="二-how-to-response-事件监听"><a href="#二-how-to-response-事件监听" class="headerlink" title="二. how to response: 事件监听"></a>二. how to response: 事件监听</h2><p>既然知晓浏览器处理用户操作的过程,那么我们就可以根据需要读对感兴趣的事件进行响应,如何响应呢？答案就是给将要响应的元素绑定事件/监听事件.在进行事件绑定的时候,我们有多种选择.首先是DOM 0 level event.</p><ol><li>DOM, Document Object Model</li></ol><p>讲到DOM 0 level, DOM1/2/3 level就有必要提一下W3C的DOM. W3C的DOM模型定义了一系列API,通过这些API你可以改变文档的结构,内容和样式.这个DOM模型的实现方法有许多条框,也就是所谓的标准;而各大浏览器要实现对网页文档的编辑,就要依据这个DOM模型的标准进行实现这一系列API就可以.</p><ol start="2"><li>DOM 0 level event</li></ol><p>由于在W3C还未正式发布DOM标准之前,各大浏览器就已经对访问文档实现了一系列API.其中,对元素进行事件绑定的API就是DOM 0 level event.这个绑定方法比较原始,它是通过在元素上内联事件绑定函数实现, 并给函数传入一个事件对象. 事件对象event包含了有关事件的一系列信息,如事件类型,事件目标等等. 使用方法例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// in javascript:</span><br><span class="line">function handler(e) &#123;</span><br><span class="line">    // do something to response the event</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">// in html:</span><br><span class="line">&lt;div id=&apos;eventTarget&apos; onclick=&apos;handler&apos;&gt;something else&lt;/div&gt;</span><br><span class="line">//in javascript: 删除该事件</span><br><span class="line">document.getElementById(&apos;eventTarget&apos;).onclick = null</span><br></pre></td></tr></table></figure></p><p>这样的绑定方法说它原始是因为:第一,它是直接绑定在目标元素上的,不易扩展;第二,它只能响应一个函数,你不能同时添加两个不同的handler去响应事件.虽然W3C DOM标准并不推荐使用该方式进行事件绑定,即便如此,它还是可以使用,因为它的支持性最广泛.</p><ol start="3"><li>DOM 2 level event</li></ol><p>接下来是DOM 2 level event. 为什么没有DOM 1 level event呢? 在W3C制定DOM 1 level标准时,并没有指定event相关的API,所以说没有DOM 1 level event.<br>在DOM 2 level event中, W3C建立了如上的事件捕获-冒泡模型. 在DOM 2 level event中,你可以选择元素响应事件的阶段,也就是说,你可以在事件捕获阶段响应事件,也可以在事件冒泡阶段响应事件.使用方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventTarget.addEventListener(event, handler, [useCapture | options])</span><br><span class="line">/*  useCapture: Boolean, 是否在捕获阶段响应事件,默认为false(在冒泡阶段)</span><br><span class="line">    options: &#123;</span><br><span class="line">        capture: Boolean, 同useCapture</span><br><span class="line">        passive: Boolean, 是否禁止在handler中使用event.preventDefault()</span><br><span class="line">        once:    Boolean, 是否只响应一次事件,响应过后即删除本事件监听器</span><br><span class="line">    &#125;</span><br><span class="line">*/</span><br><span class="line">EventTarget.removeEventListener(event, hanlder)</span><br><span class="line"></span><br><span class="line">var myEvent = new Event(&apos;myEvent&apos;)</span><br><span class="line">var myCustomerEvent = new CustomEvent(&apos;build&apos;, &#123; &apos;detail&apos;: elem.dataset.time &#125;)</span><br><span class="line">EventTarget.dispatchEvent(myEvent)</span><br><span class="line">EventTarget.dispatchEvent(myCustomerEvent)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>Microsoft</li></ol><p>就像前面讲到的一样,Microsoft的事件模型是冒泡模型,喜欢和别人不一样,它的事件绑定方法也不一样, 事件对象event也不是传递给函数,而是暴露到window对象下.使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.attachEvent(&apos;on&apos;+ event, handler)</span><br><span class="line">element.detachEvent(&apos;on&apos;+ event, handler)</span><br></pre></td></tr></table></figure><ol start="5"><li>各个事件监听的比较</li></ol><table><thead><tr><th>项目</th><th>DOM 0</th><th>DOM 2</th><th>microsoft</th></tr></thead><tbody><tr><td>绑定函数</td><td>ele.onEvent = handler</td><td>ele.addEventListener(event, handler)</td><td>ele.attach(‘on’+event, handler)</td></tr><tr><td>解绑函数</td><td>ele.onEvent = null</td><td>ele.removeEventListener(event, handler)</td><td>ele.detach(‘on’+event, handler)</td></tr><tr><td>事件对象</td><td>作为参数传递到handler</td><td>作为参数传递到handler</td><td>window.event对象</td></tr><tr><td>事件原始目标</td><td>event.target</td><td>event.target</td><td>window.event.srcElement</td></tr><tr><td>事件当前目标</td><td>event.currentTarget</td><td>event.currentTarget</td><td>window.event.currentTarget(ie&gt;9)</td></tr><tr><td>handler中的this</td><td>ele</td><td>ele</td><td>window</td></tr><tr><td>阻止事件传递</td><td>event.stopPropagation()或return false</td><td>event.stopPropagation()或return false</td><td>window.event.cancelBubble = true(ie仅是冒泡)或return false</td></tr><tr><td>阻止默认行为</td><td>event.preventDefault()</td><td>event.preventDefault()</td><td>window.event.returnValue = false</td></tr></tbody></table><ol start="6"><li>为何要区分捕获和冒泡?</li></ol><ul><li>多个元素同时监听同一个事件,了解事件触发这些元素的响应顺序;结合event.stopPropagation()阻止事件向特定方向传递</li></ul><p>从下面的代码可以看到,只要容器事件监听设置为在捕获阶段响应,就比button先响应.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 设置不同的capture值,响应顺序变化</span><br><span class="line">&lt;div id=&apos;wrapper&apos;&gt;&lt;button id=&apos;button&apos;&gt;click&lt;/button&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// case 1: 响应时机: wrapper先于button</span><br><span class="line">wrapper.addEventLister(&apos;click&apos;, handler, true)</span><br><span class="line">button.addEventLister(&apos;click&apos;, handler, true)</span><br><span class="line"></span><br><span class="line">// case 2: 响应时机: wrapper先于button</span><br><span class="line">wrapper.addEventLister(&apos;click&apos;, handler, true)</span><br><span class="line">button.addEventLister(&apos;click&apos;, handler, false)</span><br><span class="line"></span><br><span class="line">// case 3: 响应时机: button先于wrapper</span><br><span class="line">wrapper.addEventLister(&apos;click&apos;, handler, false)</span><br><span class="line">button.addEventLister(&apos;click&apos;, handler, false)</span><br><span class="line"></span><br><span class="line">// case 4: 响应时机: button先于wrapper</span><br><span class="line">wrapper.addEventLister(&apos;click&apos;, handler, false)</span><br><span class="line">button.addEventLister(&apos;click&apos;, handler, true)</span><br></pre></td></tr></table></figure><ul><li>事件监听函数内嵌套同类事件监听函数,了解嵌套监听函数的触发时机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 设置不同capture值,内部嵌套监听函数是否会立即响应</span><br><span class="line">&lt;div id=&apos;wrapper&apos;&gt;&lt;button id=&apos;button&apos;&gt;click&lt;/button&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// case 1: wrapper响应后, button立即响应</span><br><span class="line">// log: wrapper, button</span><br><span class="line">wrapper.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;wrapper&apos;)</span><br><span class="line">    button.addEventListener(&apos;click&apos;, (evt) =&gt; &#123;</span><br><span class="line">        console.log(&apos;button&apos;)</span><br><span class="line">    &#125;, false)</span><br><span class="line">&#125;, true)</span><br><span class="line"></span><br><span class="line">// case 2: wrapper响应后,button要下次点击才会响应</span><br><span class="line">// log: first-click:wrapper; second-click:button,wrapper</span><br><span class="line">div.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;wrapper&apos;)</span><br><span class="line">    btn.addEventListener(&apos;click&apos;, (evt) =&gt; &#123;</span><br><span class="line">        console.log(&apos;button&apos;)</span><br><span class="line">    &#125;, true)</span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure><ul><li>进行事件代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;wrapper&apos;&gt;</span><br><span class="line">    &lt;button id=&apos;button&apos;&gt;click&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;not click&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">wrapper.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    if (e.target.id == &apos;button&apos;) &#123;</span><br><span class="line">        console.log(&apos;click&apos;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;not click&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget</a></li><li><a href="https://www.quirksmode.org/js/events_order.html#link4" target="_blank" rel="noopener">Event order</a></li><li><a href="http://caibaojian.com/currenttarget.html" target="_blank" rel="noopener">currentTarget</a></li><li><a href="http://caibaojian.com/javascript-stoppropagation-preventdefault.html" target="_blank" rel="noopener">阻止默认行为</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript事件-发生什么事了？&quot;&gt;&lt;a href=&quot;#JavaScript事件-发生什么事了？&quot; class=&quot;headerlink&quot; title=&quot;JavaScript事件:发生什么事了？&quot;&gt;&lt;/a&gt;JavaScript事件:发生什么事了？&lt;/h1&gt;&lt;p&gt;在最近的代码中,我同时给document元素和其内部元素添加click事件监听,根据事件监听的结果来显示隐藏某个提示框.但在实现过程中,我发现,当内部元素点击显示提示框后,又会立马隐藏.看别人实现的方法,才发觉我使用的事件监听有问题,由此致使我再次读一读JavaScript中事件模型及相关知识.基于此,便有写下自己的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript事件" scheme="http://yoursite.com/tags/Javascript%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式-单例模式</title>
    <link href="http://yoursite.com/2018/06/16/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/16/JavaScript设计模式-单例模式/</id>
    <published>2018-06-16T00:30:28.000Z</published>
    <updated>2018-06-16T00:33:35.814Z</updated>
    
    <content type="html"><![CDATA[<ul><li style="list-style: none"><input type="checkbox"> 什么是单例模式?</li><li style="list-style: none"><input type="checkbox"> 单例模式的用途</li></ul><h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>单例模式，顾名思义，就是单个例子的模式，放在编程里讲，就是一种只有单个实例的编程方式。其核心理念就是单个类，只会实例化一次，即该类只有单个实例，亦即单例。那么如何实现呢？我们要注意“一个类只有一个实例”这个核心，下面我们从它的实际用途来说明。</p><a id="more"></a><h2 id="单例模式的用处"><a href="#单例模式的用处" class="headerlink" title="单例模式的用处"></a>单例模式的用处</h2><ol><li>创建命名空间</li></ol><p>在多人合作开发的过程中，难免会出现命名冲突的情况；在这种情况下，为了防止命名冲突导致的变量、函数重载，我们可以为开发人员定义一个对象，将该开发人员定义的所有变量和函数都挂载在该对象上。对于该对象类来说，这个对象的所谓实例就是其本身，也就符合单个类只有单个实例一说.代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// namespace</span><br><span class="line">var BaiduTieba = &#123;</span><br><span class="line">    reply: function () &#123; /*...回复私信...*/ &#125;,</span><br><span class="line">    recept: function () &#123; /*...接收私信...*/ &#125;</span><br><span class="line">&#125;</span><br><span class="line">var BaiduZhidao = &#123;</span><br><span class="line">    query: function () &#123; /*...查询问题...*/ &#125;,</span><br><span class="line">    answer: function () &#123; /*...回答问题...*/ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面我们可以看出，使用单例模式的最简单方法就是使用对象字面量定义，BaiduTieba和BaiduZhidao类的实例就是这两个对象(因为它不能使用new进行实例化)。在jQuery中，jQuery就是类似的以单例形式形成的命名空间。</p><ol start="2"><li>实现静态变量</li></ol><p>在ES6的const出现以前，没有什么变量是不能重载的；一不小心就把某个具有特定值的变量进行重新赋值。而在许多情况下，我们需要保证一些变量的值是不变的，也就是说要使其成为静态变量，这在读取完配置文件时十分常见；如果需要进行访问或修改的话，则需要我们通过特定的方法进行。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var Config = (function () &#123;</span><br><span class="line">    var conf = &#123;</span><br><span class="line">        MAX_NUM: 100,</span><br><span class="line">        MIN_NUM: 10,</span><br><span class="line">        COUNT: 1000</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        get: function (name) &#123;</span><br><span class="line">            return conf[name] &amp;&amp; conf[name];</span><br><span class="line">        &#125;</span><br><span class="line">        set: function (name, value) &#123;</span><br><span class="line">            return conf[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>在上面那个例子中，Config使用闭包保证config参数无法被外部直接修改，也就间接地实现了静态变量config。如果要访问或者修改的话，则必需通过Config.get和Config.set函数.可以看到，这个例子最终的返回值其实与创建命名空间是相类似的，那也同样符合“单个类只有单个实例”一说。</p><ol start="3"><li>惰性创建对象</li></ol><p>在有些时候，我们没有必要立刻创建某个变量，而是在需要的时候进行创建；这有点类似按需加载的意味.这也就是所谓的惰性单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var Lazy = (function () &#123;</span><br><span class="line">    var instance = null;</span><br><span class="line">    </span><br><span class="line">    function Singleton () &#123;</span><br><span class="line">        // 定义私有的属性和方法</span><br><span class="line">        var privateMethod = function () &#123;&#125;;</span><br><span class="line">        var privateProperty = function () &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        // 定义供外部访问的属性和方法</span><br><span class="line">        return &#123;</span><br><span class="line">            publicMethod: function () &#123;&#125;,</span><br><span class="line">            publicProperty: null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (!instance) &#123;</span><br><span class="line">            instance = Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>从代码看，仍旧是使用闭包来实现单例模式，但这里的单例不再是为了实现静态变量；而是真正实现内部函数Singleton的单例模式，只有在我们调用Lazy后，我们才能获得Singleton的一个实例；无论调用多少次，都是该实例；也就是说，Lazy实现了Singleton只有一个实例存在,也符合“单个类单个实例”一说。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = Lazy(); a;</span><br><span class="line">// =&gt; &#123;publicMethod: ƒ, publicProperty: null&#125;</span><br><span class="line">var b = Lazy(); b;</span><br><span class="line">// =&gt; &#123;publicMethod: ƒ, publicProperty: null&#125;</span><br><span class="line">a === b;</span><br><span class="line">// =&gt; true</span><br></pre></td></tr></table></figure></p><blockquote><p>在阅读里面给的第一篇<a href="https://note.youdao.com/" target="_blank" rel="noopener">《JavaScript设计模式—-单例模式》</a>中，2.1下方的实现惰性单例有误，“var a = Singleton.getInstance(‘seven1’);var b = Singleton.getInstance(‘seven2’);”中没有返回值，a和b均为undefined，a===b自然为true。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/giggle/p/5452271.html" target="_blank" rel="noopener">JavaScript之单例实战</a></li><li><a href="https://www.cnblogs.com/cangowu/p/5062130.html" target="_blank" rel="noopener">JavaScript设计模式之单例模式</a></li><li><a href="https://blog.csdn.net/yisuowushinian/article/details/52003127" target="_blank" rel="noopener">JavaScript设计模式—-单例模式</a></li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式-张容铭著</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 什么是单例模式?&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 单例模式的用途&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是单例模式？&quot;&gt;&lt;a href=&quot;#什么是单例模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式？&quot;&gt;&lt;/a&gt;什么是单例模式？&lt;/h2&gt;&lt;p&gt;单例模式，顾名思义，就是单个例子的模式，放在编程里讲，就是一种只有单个实例的编程方式。其核心理念就是单个类，只会实例化一次，即该类只有单个实例，亦即单例。那么如何实现呢？我们要注意“一个类只有一个实例”这个核心，下面我们从它的实际用途来说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用R对实验数据进行方差分析</title>
    <link href="http://yoursite.com/2018/05/13/%E5%88%A9%E7%94%A8R%E5%AF%B9%E5%AE%9E%E9%AA%8C%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/13/利用R对实验数据进行方差分析/</id>
    <published>2018-05-13T12:35:33.000Z</published>
    <updated>2018-05-13T12:37:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>在经历很久的实验之后，大家好不容易获得大量数据。对于这些数据，老板们最关心的就是这些数据有没有差异（老板：这数据怎么没有差异呢？是不是你做的有问题？。。。。害怕）。相信大部分同学平常都是使用SPSS进行差异分析，简单快捷粗暴。在学习《R语言与实战》相关章节之后，我们就可以使用R进行差异分析啦。在本文中，我将记录一下我学习使用R进行差异分析的一般过程, 含如何引入数据、数据预处理、相关性分析、差异分析等部分。</p><a id="more"></a><h3 id="方差分析的流程"><a href="#方差分析的流程" class="headerlink" title="方差分析的流程"></a>方差分析的流程</h3><p>使用R进行方差分析的基本流程如下，分为三步，再简单点，甚至可以省略第二步。这通常与最初的实验设计相关，譬如进行癌症治疗的话，我们明显知道进行放疗和化疗所获得的治疗数据是相互独立的，这种情况下，我们并不需要进行相关性分析。但是，如果拿到的数据我们并不清楚其中的相关性的话，就需要进行相关性分析。因为这涉及到后面差异性分析中分析方法的选择。</p><ol><li>导入数据</li><li>相关性分析</li><li>差异性分析</li></ol><h3 id="第一步-导入数据"><a href="#第一步-导入数据" class="headerlink" title="第一步 导入数据"></a>第一步 导入数据</h3><p>在R语言中，大量包的存在使得数据导入的方法也变得多种多样。除了基本通过数据输入、从文本读取，R还允许从excel、SAS、spss等软件的数据文件进行读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 常见的数据导入方法</span><br><span class="line">// 键盘输入</span><br><span class="line">mydata &lt;- edit(mydata)</span><br><span class="line">// 从文本导入</span><br><span class="line">read.table(file, header=TRUE, sep=&apos;\t&apos;, row.names=c(...))       // header指定文本中是否携带header</span><br><span class="line">// 从excel, .xls文件</span><br><span class="line">channel &lt;- RODBC::odbcConnectExcel(&apos;myfile.xls&apos;)</span><br><span class="line">RODBC::sqlFetch(channel, &apos;mysheet&apos;)</span><br><span class="line">RODBC::odbcClose(channel)</span><br><span class="line">// 从excel, .xlsx文件</span><br><span class="line">xlsx::read.xlsx(workbook, 1)</span><br><span class="line">// 从XML格式文件</span><br><span class="line">使用XML包</span><br><span class="line">// 从网络</span><br><span class="line">readlines(url)</span><br><span class="line">RCurl、XML包</span><br><span class="line">// 从SPSS</span><br><span class="line">foreign::read.spss(file)</span><br><span class="line">Hmisc::spss.get(file)</span><br><span class="line">// 从SAS</span><br><span class="line">foreign::read.ssd(file), Hmisc::sas.get(file)</span><br></pre></td></tr></table></figure><h4 id="随机生成数据"><a href="#随机生成数据" class="headerlink" title="随机生成数据"></a>随机生成数据</h4><p>假定我们要考虑药物A和药物B对于感冒的治疗效果，于是我们准备n只小鼠，按下列条件进行给药2个月：20 mg/kg, 40 mg/kg, 60mg/kg.期间收集数据。所以我们的分组就应该是如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drugA       drugB</span><br><span class="line">20mg/kg     20mg/kg</span><br><span class="line">40mg/kg     40mg/kg</span><br><span class="line">50mg/kg     50mg/kg</span><br></pre></td></tr></table></figure></p><p>这个时候，我们有两种方法进行比较：1）同个药物，比较不同剂量的治疗效果。2）同个剂量，比较不同药物的治疗效果。下面，我们进行随机生成所需的数据。查阅到，进行生成随机数的统一形式是：前缀+分布函数。</p><table><thead><tr><th>前缀</th><th>函数</th><th>示例：正态函数</th></tr></thead><tbody><tr><td>d</td><td>密度函数</td><td>dnorm</td></tr><tr><td>r</td><td>随机函数</td><td>rnorm</td></tr><tr><td>p</td><td>分布函数</td><td>pnorm</td></tr><tr><td>q</td><td>分位数函数</td><td>qnorm</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">drugA_means &lt;- c(10, 15, 20)</span><br><span class="line">drugB_means &lt;- c(12, 18, 26)</span><br><span class="line">doses &lt;- c(&apos;20&apos;, &apos;40&apos;, &apos;60&apos;)</span><br><span class="line"></span><br><span class="line">drugA &lt;- data.frame(row.names = 1:6)</span><br><span class="line">drugB &lt;- data.frame(row.names = 1:6)</span><br><span class="line"></span><br><span class="line">drugA$drug &lt;- rep(&apos;drugA&apos;, 6)</span><br><span class="line">drugA$drug &lt;- rep(&apos;drugA&apos;, 6)</span><br><span class="line"></span><br><span class="line">for (i in 1:3) &#123;</span><br><span class="line">  drugA[paste(&apos;drugA&apos;, doses[i], sep=&apos;_&apos;)] &lt;- rnorm(6, drugA_means[i], sd=runif(1, 0.5, 1))</span><br><span class="line">  drugB[paste(&apos;drugB&apos;, doses[i], sep=&apos;_&apos;)] &lt;- rnorm(6, drugB_means[i], sd=runif(1, 0.5, 1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果有需要的话，可以使用reshape包将drugA和drugB进行融合，然后按需要进行处理</span><br><span class="line">library(reshape)</span><br><span class="line">drug &lt;- rbind(melt(drugA), melt(drugB))</span><br><span class="line"></span><br><span class="line">colnames(drug) &lt;- c(&apos;drug&apos;, &apos;dose&apos;, &apos;effects&apos;)</span><br><span class="line">// 批量修改dose, 如果生成数据时不添加drugA, drugA_20之类的，就不用修改</span><br><span class="line">with(drug, &#123;</span><br><span class="line">  dose &lt;- as.character(dose)    // 作为factor的话，无法用后续方法修改</span><br><span class="line">  dose[dose == &apos;drugA_20&apos; | dose == &apos;drugB_20&apos;] &lt;- 20</span><br><span class="line">  dose[dose == &apos;drugA_40&apos; | dose == &apos;drugB_40&apos;] &lt;- 40</span><br><span class="line">  dose[dose == &apos;drugA_60&apos; | dose == &apos;drugB_60&apos;] &lt;- 60</span><br><span class="line">  dose &lt;- as.numeric(dose)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">head(drug)</span><br><span class="line">/*</span><br><span class="line"> *    drug     dose   effects</span><br><span class="line"> *1  drugA      20  9.506953</span><br><span class="line"> *2  drugA      20 11.500453</span><br><span class="line"> *3  drugA      20  9.665530</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="第二步-初步分析"><a href="#第二步-初步分析" class="headerlink" title="第二步 初步分析"></a>第二步 初步分析</h3><p>在导入数据以后，我们想要知道药物A和药物B数据的基本统计情况，就可以进行描述性统计分析。比如我们想知道每个药物的平均疗效？在各个剂量下的平均疗效？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 探究药物的平均疗效</span><br><span class="line">mean(drugA$effects)         // 14.92</span><br><span class="line">mean(drugB$effects)         // 18.54</span><br><span class="line"></span><br><span class="line">// drugA_20</span><br><span class="line">drugA_20_effects &lt;- drug[drug$dose == &apos;drugA_20&apos;,]$effects      // 注意逗号，需要引用出数据框</span><br><span class="line">mean(drugA_20_effects)      // 10.25</span><br><span class="line">drugB_20_effects &lt;- drug$effects[drug$dose == &apos;drugB_20&apos;]       // 这里无逗号，因为drug$effects输出的只是一列数据</span><br><span class="line">mean(drugB_20_effects)      // 11.42</span><br></pre></td></tr></table></figure></p><p>通过分析我们发现，药物B的平均疗效要好于药物B。而且在20mg/kg的剂量下，也要好一点。也就是说药物B要比药物A好用一点。假设我们不知道药物剂量对疗效的影响，为了了解这种影响，我们需要知道：药物剂量与疗效的相关性如何？这时候，我们需要对这两个变量进行独立性检验。</p><blockquote><p>什么是相关性？当我们说相关性时，指的是两个变量之间的相关性。如药物剂量20,40,60与疗效的相关性。一般来说，两个变量的相关性通常是指变量之间的关系如何，如变量A的变化是否与变量B的变化有关，B能否解释A的变化，A是否依赖B的变化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 进行独立性检验/相关性检验</span><br><span class="line">drugA &lt;- drug[drug$drug == &apos;drugA&apos;,]</span><br><span class="line">cor(drugA$effects, drugA$dose)              // 0.983</span><br><span class="line">cor.test(drugA$effects, drugA$dose)</span><br><span class="line">/*</span><br><span class="line"> *Pearson&apos;s product-moment correlation</span><br><span class="line"></span><br><span class="line"> *data:  drugA$effects and drugA$dose</span><br><span class="line"> *t = 21.325, df = 16, p-value = 3.551e-13</span><br><span class="line"> *alternative hypothesis: true correlation is not equal to 0</span><br><span class="line"> *95 percent confidence interval:</span><br><span class="line"> * 0.9535355 0.9937360</span><br><span class="line"> *sample estimates:</span><br><span class="line"> *      cor </span><br><span class="line"> *0.9828591</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>从相关性检验结果cor()的结果可以看出，药物A的剂量与疗效呈现出很强的相关性；而相关性的显著性检验cot.test()函数的结果p-value为3.55e-13表明，剂量与疗效呈现显著正相关的关系。值得注意的是，我们可以看到cor.test结果首行表明使用的是Pearson相关系数。而在实际情况中，有多种相关性系数。从下面来看，似乎spearman更适合本此实验分析。</p><ul><li>Pearson相关系数: 衡量了两个定量变量之间的线性相关程度。</li><li>Spearman相关系数: 衡量分级定序变量之间的相关程度.</li><li>Kendall相关系数: 一种非参数的等级相关度量.</li><li>偏相关系数: 在控制一个或多个定量变量时，另外两个定量变量之间的相互关系</li><li>多格相关系数</li><li>多列相关系数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cor.test(drugA$effects, drugA$dose, method=&apos;spearman&apos;)      // p-value = 3.927e-09</span><br></pre></td></tr></table></figure><h3 id="第三步-差异分析"><a href="#第三步-差异分析" class="headerlink" title="第三步 差异分析"></a>第三步 差异分析</h3><p>在了解到药物的剂量和疗效具有明显的相关性之后，我们更加关心两种药物A和B的疗效之间的差异、各个剂量之间的差异，因此，我们需要进行差异分析，这类差异分析是组间差异分析。那么如何选择差异分析的方法？</p><p><a href="https://imgchr.com/i/CDG4W4" target="_blank" rel="noopener">组间差异分析方法的选择</a><br><img src="https://s1.ax1x.com/2018/05/13/CDG4W4.md.png" alt="CDG4W4.md.png">]</p><p>通过上图我们可以得知，如果要分析药物A和药物B疗效的差异，需要使用独立性的 t-test. 而要分析同种药物不同剂量之间的疗效差异则需要使用单因素方差分析.<br>t-test结果表明，药物A和药物B的疗效没有什么差异。而对于药物A来讲，不同的药物剂量疗效明显不同，60mg/kg的剂量疗效最好；而且各个剂量之间都存在明显的疗效差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 进行独立样本的t-test</span><br><span class="line">t.test(drugA$effects, drugB$effects)</span><br><span class="line">t.test(drug$effects ~ drug$drug)    // 这两种写法结果一致，注意drug$drug是个类型变量，drugA和drugB</span><br><span class="line">/*</span><br><span class="line">*Welch Two Sample t-test</span><br><span class="line"></span><br><span class="line">*   data:  drugA$effects and drugB$effects</span><br><span class="line">*   t = -2.053, df = 29.402, p-value = 0.04906</span><br><span class="line">*   alternative hypothesis: true difference in means is not equal to 0</span><br><span class="line">*   95 percent confidence interval:</span><br><span class="line">*    -7.20625717 -0.01587158</span><br><span class="line">*   sample estimates:</span><br><span class="line">*   mean of x mean of y </span><br><span class="line">*    14.92506  18.53612 </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 进行单因素方差分析</span><br><span class="line">// 由于drugA/drugB的effects已经按照dose进行排列，无需进行整合</span><br><span class="line">fit &lt;- aov(drugA$effects ~ drugA$dose)      // formula: y ~ A</span><br><span class="line">summary(fit)        // 查看方差分析结果</span><br><span class="line">//  Df Sum Sq Mean Sq F value   Pr(&gt;F)    </span><br><span class="line">//  state.region  3  8.344  2.7815   12.98 2.86e-06 ***</span><br><span class="line">//  Residuals    46  9.861  0.2144</span><br><span class="line"></span><br><span class="line">// 可以看到，单因素方差的结果显示p-value为2.89e-86，有显著性差异；但是并没有各个dose的差异比较。</span><br><span class="line">// 基于此，我们需要进行两两成对比较</span><br><span class="line">TtukeyHSD(fit)</span><br><span class="line"></span><br><span class="line">/*          diff      lwr       upr p adj</span><br><span class="line"> *  40-20 4.429784 3.256677  5.602892 2e-07</span><br><span class="line"> *  60-20 9.599009 8.425902 10.772117 0e+00</span><br><span class="line"> *  60-40 5.169225 3.996117  6.342332 0e+00</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="第四步-评估差异分析的假设条件是否满足"><a href="#第四步-评估差异分析的假设条件是否满足" class="headerlink" title="第四步 评估差异分析的假设条件是否满足"></a>第四步 评估差异分析的假设条件是否满足</h3><p>在单因素方差分析中，我们通常假设变量满足正态分布和方差相等（方差齐性）。为了保证差异分析结果的可靠性，我们需要对进行差异分析的变量做假设条件验证。对于正态分布，可以使用Q-Q plot。对于正态分布的变量来说，变量的值总是在对角线附近随机分布，落在95%的置信区间以内。对于方差齐性检测，可以使用bartlett检验， flinger-killeen检验或者Brown-Forsythe检验进行检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Q-Q plot</span><br><span class="line">library(car)</span><br><span class="line">qqPlot(lm(drugA$effects ~ drugA$dose), simulate=TRUE, main=&apos;Q-Q plot&apos;, labels=FALSE)</span><br><span class="line"></span><br><span class="line">// 方差齐性检验</span><br><span class="line">bartlett.test(effects ~ dose, data=drugA)</span><br><span class="line">fligner.test(effects ~ dose, data=drugA)</span><br><span class="line">HH::hov.test(effects ~ dose, data=drugA))</span><br><span class="line"></span><br><span class="line">// 由于方差齐性对于离群点相当敏感，需检测是否存在离群点；若存在，删除之然后再重新进行差异分析</span><br><span class="line">car::outlier()</span><br></pre></td></tr></table></figure><h3 id="第五步-进行简单地可视化数据"><a href="#第五步-进行简单地可视化数据" class="headerlink" title="第五步 进行简单地可视化数据"></a>第五步 进行简单地可视化数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A_effects &lt;- cbind(mean(drugA$effects[drugA$dose == &apos;20&apos;]), mean(drugA$effects[drugA$dose == &apos;40&apos;]), mean(drugA$effects[drugA$dose == &apos;60&apos;]))</span><br><span class="line">B_effects &lt;- cbind(mean(drugB$effects[drugB$dose == &apos;20&apos;]), mean(drugB$effects[drugB$dose == &apos;40&apos;]), mean(drugB$effects[drugB$dose == &apos;60&apos;]))</span><br><span class="line">effects &lt;- t(rbind(A_effects, B_effects))</span><br><span class="line">colnames(effects) &lt;- c(&apos;drugA&apos;, &apos;drugB&apos;)</span><br><span class="line">rownames(effects) &lt;- c(&apos;20&apos;, &apos;40&apos;, &apos;60&apos;)</span><br><span class="line"></span><br><span class="line">barplot(effects, legend=TRUE, beside=TRUE)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在经历很久的实验之后，大家好不容易获得大量数据。对于这些数据，老板们最关心的就是这些数据有没有差异（老板：这数据怎么没有差异呢？是不是你做的有问题？。。。。害怕）。相信大部分同学平常都是使用SPSS进行差异分析，简单快捷粗暴。在学习《R语言与实战》相关章节之后，我们就可以使用R进行差异分析啦。在本文中，我将记录一下我学习使用R进行差异分析的一般过程, 含如何引入数据、数据预处理、相关性分析、差异分析等部分。&lt;/p&gt;
    
    </summary>
    
      <category term="R语言" scheme="http://yoursite.com/categories/R%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="方差分析" scheme="http://yoursite.com/tags/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>R语言入门之数据类型简介</title>
    <link href="http://yoursite.com/2018/05/13/R%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/05/13/R语言入门之数据类型简介/</id>
    <published>2018-05-12T23:24:51.000Z</published>
    <updated>2018-05-12T23:44:06.678Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，R是一门用于统计计算和作图的语言。但是，R不仅仅只是一门编程语言，由开发者们所提供的海量R包，使得R更像是一个用于数据计算与分析的环境。R是一个非常灵活的平台，是专用于探索、展示和理解数据的语言。既然在R中，一切都是与数据有关。那么就让我们先来认识一下R语言中，数据有哪些表示结构或者类型。<br><a id="more"></a></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>在R语言中，一切操作都与数据有关，但是在大部分情况下，数据并不是单一出现，而是作为一个整体或者集合出现，譬如学校中某个班级中男生的身高。我们将这类数据集合称之为数据集。数据集具有一定的组成结构，它通常是一个矩形数组，数组的行表示观测，列表示变量。如身高值，height作为列名，表示身高这一变量；男生A、B…作为行名，表示每一个观测值即身高具体值。这与统计学中的观测和变量是一致的。而在其他行业中，比如数据库，变量又被称为字段，观测则是记录；如果在机器学习中，观测则被取名为示例，变量作为属性出现。</p><h2 id="R语言中的数据对象类型"><a href="#R语言中的数据对象类型" class="headerlink" title="R语言中的数据对象类型"></a>R语言中的数据对象类型</h2><p>虽然数据大部分以数据集的形式存在，但是如果就此将数据统一以数据集的形式进行操作处理，并不适合所有情境；针对特定的处理情境，产生特定的数据结构及相关操作才是最富效率的。在R语言中，用于存储数据的对象类型有：标量、向量、矩阵、数组、数据框和列表。其中，标量只是一个意义名词，本质上是一个只含单个元素的向量。</p><h3 id="1-向量"><a href="#1-向量" class="headerlink" title="1.向量"></a>1.向量</h3><p>与其他编程语言相类比的话，向量对标的是一维数组，但其定义使用的不是“[  ]”，而是“(   )”。它可以存储数值型数据、字符型数据、逻辑型数据。值得注意的是，向量里面的元素需要保持数据类型的一致性，不能混合多种数据类型。以下是常用的创建向量的途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- c(1, 2, 3)             // [1] 1 2 3</span><br><span class="line">a &lt;- seq(1, 6, by=2)        // [1] 1 3 5</span><br><span class="line">a &lt;- 1:4                    // [1] 1 2 3 4</span><br><span class="line">rep(1:4, times=2)           // [1] 1 2 3 4 1 2 3 4</span><br><span class="line">rep(1:4, each=2)            // [1] 1 1 2 2 3 3 4 4</span><br></pre></td></tr></table></figure><h3 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2.矩阵"></a>2.矩阵</h3><p>与向量类似，矩阵对标的是二维数组；个人认为矩阵是对向量的自然推广。它是一个二维数据，包含的元素同样要保持数据类型的一致性。注意，矩阵是不含行名和列名等信息的，是纯粹的二维数据集。<br>矩阵在创建时按列进行填充，可以指定byrow参数实现按行填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">matrix(1:10, nrow=2)</span><br><span class="line">//      [,1] [,2] [,3] [,4] [,5]</span><br><span class="line">// [1,]    1    3    5    7    9</span><br><span class="line">// [2,]    2    4    6    8   10</span><br><span class="line"></span><br><span class="line">// 注意上下两次矩阵的区别.</span><br><span class="line">matrix(1:10, nrow=2, byrow=TRUE)</span><br><span class="line">//      [,1] [,2] [,3] [,4] [,5]</span><br><span class="line">// [1,]    1    2    3    4    5</span><br><span class="line">// [2,]    6    7    8    9   10</span><br></pre></td></tr></table></figure><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><p>数组又是对矩阵的自然推广，可以包含3维及以上的数据集。它也要保证元素的数据类型一致性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个2x3x4的数值型数组</span><br><span class="line">dim1 &lt;- c(&apos;a1&apos;, &apos;a2&apos;)</span><br><span class="line">dim2 &lt;- c(&apos;b1&apos;, &apos;b2&apos;, &apos;b3&apos;)</span><br><span class="line">dim3 &lt;- c(&apos;c1&apos;, &apos;c2&apos;, &apos;c3&apos;, &apos;c4&apos;)</span><br><span class="line">z &lt;- array(1:24, c(2, 3, 4), dimnames=list(dim1, dim2, dim3))</span><br></pre></td></tr></table></figure><h3 id="4-数据框"><a href="#4-数据框" class="headerlink" title="4.数据框"></a>4.数据框</h3><p>数据框的列可以包含不同模式的数据，该概念较矩阵来说更为一般；但是，每一列的列内部数据的模式必须唯一。<br>    实例标识符可通过data.frame的rowname选项指定。<br>    我们应该注意到，从形式上看，数据框与矩阵的形式是一致的，有行列组成的数据集。但是，数据框包含了其他的额外信息：行名和列名，列内部的数据类型一致性，以及列与列之间的数据类型可异性。就这点看，数据框的使用场景较之矩阵更为一般。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 列向量col1, col2, col3可为任何类型，每一列的名称可由函数names指定</span><br><span class="line">col1 &lt;- </span><br><span class="line">mydata &lt;- data.frame(col1, col2, col3, ...)</span><br></pre></td></tr></table></figure><h3 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h3><p>列表是一种比数据框、数组更为一般的数据类型。它允许不同的元素类型，这些元素类型可以是任意的对象，即其元素既可以是数组、矩阵、数据框，还可以是列表。列表这种数据结构存在的意义在于整合多个不同（无论是否有关联）的对象，形成一个由多种成分和对象的有序集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">partmt &lt;- mtcars[1:5, 1:5]</span><br><span class="line">a &lt;- list(name=&apos;John&apos;, score=c(110, 112, 98, 124), age=30, cars=partmt)</span><br><span class="line"></span><br><span class="line">//    $name</span><br><span class="line">//    [1] &quot;John&quot;</span><br><span class="line">//    </span><br><span class="line">//    $score</span><br><span class="line">//    [1] 110 112  98 124</span><br><span class="line">//    </span><br><span class="line">//    $age</span><br><span class="line">//    [1] 30</span><br><span class="line">//    </span><br><span class="line">//    $cars</span><br><span class="line">//                       mpg cyl disp  hp drat</span><br><span class="line">//    Mazda RX4         21.0   6  160 110 3.90</span><br><span class="line">//    Mazda RX4 Wag     21.0   6  160 110 3.90</span><br><span class="line">//    Datsun 710        22.8   4  108  93 3.85</span><br></pre></td></tr></table></figure><h3 id="6-数据的引用"><a href="#6-数据的引用" class="headerlink" title="6.数据的引用"></a>6.数据的引用</h3><p>对于所有数据结构中的元素来讲，基本上都可以通过下标进行引用；但其中还有一些区别.例如：</p><ul><li><p>元素引用通过下标，从1开始引用，超过元素个数的引用得到NA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- c(1, 2, 3)</span><br><span class="line">a[1]    // 1</span><br><span class="line">a[4]    // NA</span><br></pre></td></tr></table></figure></li><li><p>矩阵、数组、数据框的引用区分行列。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mtcars[1:2,]    // 添加逗号后，表明引用的是第1和第2行</span><br><span class="line">mtcars[1:2]     // 无逗号，引用的是第1列和第2列</span><br><span class="line">mtcars[1:2, 1:2]    // 引用1-2行中的1-2列</span><br></pre></td></tr></table></figure><ul><li><p>对于列名（标识符）的数据类型还可以通过标识符进行引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mtcars$mpg      // 引用第1列</span><br><span class="line">mtcars[,1]，mtcars[1]      // 与$mpg的引用结果相同</span><br></pre></td></tr></table></figure></li><li><p>对于列表来说，单个[]和双[[]]是不同的；前者引用结果是由被引用元素形成的列表，后者引用元素本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- list(name=&apos;John&apos;, score=c(110, 112, 98, 124), age=30, cars=partmt)</span><br><span class="line">a[2]            // 110 112 98 124</span><br><span class="line">class(a[2])     // &quot;list&quot;</span><br><span class="line">a[[2]]          // 110 112 98 124</span><br><span class="line">classs(a[[2]])  // &quot;numeric&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h3><p>因子，表面与数据结构无关；但通常与数据结构中的变量（即行）十分相关，有利于进一步表征数据的内在含义。通常来讲，变量可以分为名义型（分类型）、连续型或者有序型变量，这些变量都可以作为因子出现。<br>连续型变量通常是指那些可以得到连续性数据的变量，比如身高、体重等，这类变量可以是某个范围的任意值，可以同时表示顺序和数量，例如顺序上可以按照身高排序。<br>有序型变量通常指那些自带顺序的变量，比如学生的成绩排名，甚至粗暴点讲，时间日期等，它注重表达一种顺序关系，而非数量关系。<br>名义型变量是没有顺序之分的类别变量（分类型），比如男女性别之分。<br>使用因子的优点在于：对数据进行分类分组表示，便于数据分析、发现错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name &lt;- c(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;)</span><br><span class="line">sex &lt;- c(&apos;female&apos;, &apos;female&apos;, &apos;male&apos;, &apos;female&apos;)</span><br><span class="line">weight &lt;- c(45, 50, 62, 48)</span><br><span class="line">roles &lt;- data.frame(name, sex, weight)</span><br><span class="line">roles$sex &lt;- factor(roles$sex, levels=c(&apos;female&apos;, &apos;male&apos;), ordered=TRUE)</span><br><span class="line">// 通常来讲，R会自动将那些字符型变量转化为因子</span><br><span class="line"></span><br><span class="line">levels(roles$sex)   // &quot;female&quot; &quot;male&quot;</span><br><span class="line">droplevels(roles$sex)   // 删除无用的level, 例如female, male中含有kid这一level。</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>R语言中的数据结构有向量、矩阵、数组、数据框和列表，可以以下标的形式进行引用数据；数据框和列表也可以通过标识符引用数据。因子是对变量的一种定义，将变量进行分类排序，以利于数据分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，R是一门用于统计计算和作图的语言。但是，R不仅仅只是一门编程语言，由开发者们所提供的海量R包，使得R更像是一个用于数据计算与分析的环境。R是一个非常灵活的平台，是专用于探索、展示和理解数据的语言。既然在R中，一切都是与数据有关。那么就让我们先来认识一下R语言中，数据有哪些表示结构或者类型。&lt;br&gt;
    
    </summary>
    
      <category term="R语言" scheme="http://yoursite.com/categories/R%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
